import argparse

from cv2 import findHomography

from ImageRecognition.edgeDetectionLive2 import GetCardCorner
import cv2
import numpy as np
import argparse

cap = cv2.VideoCapture(1, cv2.CAP_DSHOW)


def nms(boxes, overlapThresh=0.4):
    # Return an empty list, if no boxes given
    if len(boxes) == 0:
        return []
    x1 = boxes[:, 0]  # x coordinate of the top-left corner
    y1 = boxes[:, 1]  # y coordinate of the top-left corner
    x2 = boxes[:, 2]  # x coordinate of the bottom-right corner
    y2 = boxes[:, 3]  # y coordinate of the bottom-right corner
    # Compute the area of the bounding boxes and sort the bounding
    # Boxes by the bottom-right y-coordinate of the bounding box
    areas = (x2 - x1 + 1) * (y2 - y1 + 1)  # We add 1, because the pixel at the start as well as at the end counts
    # The indices of all boxes at start. We will redundant indices one by one.
    indices = np.arange(len(x1))
    for i, box in enumerate(boxes):
        # Create temporary indices
        temp_indices = indices[indices != i]
        # Find out the coordinates of the intersection box
        xx1 = np.maximum(box[0], boxes[temp_indices, 0])
        yy1 = np.maximum(box[1], boxes[temp_indices, 1])
        xx2 = np.minimum(box[2], boxes[temp_indices, 2])
        yy2 = np.minimum(box[3], boxes[temp_indices, 3])
        # Find out the width and the height of the intersection box
        w = np.maximum(0, xx2 - xx1 + 1)
        h = np.maximum(0, yy2 - yy1 + 1)
        # compute the ratio of overlap
        overlap = (w * h) / areas[temp_indices]
        # if the actual boungding box has an overlap bigger than treshold with any other box, remove it's index
        if np.any(overlap) > overlapThresh:
            indices = indices[indices != i]
        # return only the boxes at the remaining indices
    return boxes[indices].astype(int)
    pass


while (1):
    _, frame = cap.read()
    # cardCorner = GetCardCorner()
    # cardCornerFrame = cardCorner.GetCardCorner(frame)

    print("[INFO] loading images...")
    image = frame  # cv2.imread("image")
    template = cv2.imread("./Images/2.jpg")
    (tH, tW) = template.shape[:2]
    # display the  image and template to our screen
    cv2.imshow("Image", image)
    cv2.imshow("Template", template)

    # convert both the image and template to grayscale
    imageGray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    templateGray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)
    # perform template matching
    print("[INFO] performing template matching...")
    result = cv2.matchTemplate(imageGray, templateGray,
                               cv2.TM_CCOEFF_NORMED)

    # find all locations in the result map where the matched value is
    # greater than the threshold, then clone our original image so we
    # can draw on it
    (yCoords, xCoords) = np.where(result >= 0.8)
    clone = image.copy()
    print("[INFO] {} matched locations *before* NMS".format(len(yCoords)))
    # loop over our starting (x, y)-coordinates
    for (x, y) in zip(xCoords, yCoords):
        # draw the bounding box on the image
        cv2.rectangle(clone, (x, y), (x + tW, y + tH),
                      (255, 0, 0), 3)
    # show our output image *before* applying non-maxima suppression
    # cv2.imshow("Before NMS", clone)
    # cv2.waitKey(0)

    # initialize our list of rectangles
    rects = []
    # loop over the starting (x, y)-coordinates again
    for (x, y) in zip(xCoords, yCoords):
        # update our list of rectangles
        rects.append((x, y, x + tW, y + tH))
    # apply non-maxima suppression to the rectangles
    pick = nms(np.array(rects))
    print("[INFO] {} matched locations *after* NMS".format(len(pick)))
    # loop over the final bounding boxes
    for (startX, startY, endX, endY) in pick:
        # draw the bounding box on the image
        cv2.rectangle(image, (startX, startY), (endX, endY),
                      (255, 0, 0), 3)
        cv2.putText(image, "2", (startX, startY), cv2.FONT_HERSHEY_SIMPLEX,
                    1.0, (0, 255, 0))

    # show the output image
    cv2.imshow("After NMS", image)
    cv2.waitKey(0)

    k = cv2.waitKey(5) & 0xFF
    if k == 27:
        break

    """
    # OLD STUFF
    print("[INFO] loading images...")
    image = frame #cv2.imread("image")
    template = cv2.imread("./Images/diamondenkel.jpg")
    cv2.imshow("Image", image)
    cv2.imshow("Template", template)
    # convert both the image and template to grayscale
    imageGray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    templateGray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)
    print("[INFO] performing template matching...")
    result = cv2.matchTemplate(imageGray, templateGray,
                               cv2.TM_CCOEFF_NORMED)
    (minVal, maxVal, minLoc, maxLoc) = cv2.minMaxLoc(result)
    # determine the starting and ending (x, y)-coordinates of the
    # bounding box
    (startX, startY) = maxLoc
    endX = startX + template.shape[1]
    endY = startY + template.shape[0]
    # draw the bounding box on the image
    cv2.rectangle(image, (startX, startY), (endX, endY), (255, 0, 0), 3)
    # show the output image
    cv2.imshow("Output", image)
    cv2.waitKey(0)
    """

    """
    img_rgb = frame
    img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)
    template = cv2.imread('./Images/diamondny.png', 0)
    #template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)
    w, h = template.shape[::-1]
    res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)
    threshold = 0.8
    loc = np.where(res >= threshold)
    for pt in zip(*loc[::-1]):
        cv2.rectangle(img_rgb, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 2)
    cv2.imwrite('es.png', img_rgb)

    cv2.imshow('image2', frame)
    """
